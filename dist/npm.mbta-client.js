(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["npm.mbta-client"],{

/***/ "0JQN":
/*!***************************************************!*\
  !*** ./node_modules/mbta-client/lib/constants.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = {\n  Attributes: {\n    arrival_time: 'arrival_time',\n    departure_time: 'departure_time',\n  },\n  Pagination: {\n    first: 'first',\n    next: 'next',\n    prev: 'prev',\n    last: 'last',\n  },\n};\n\n\n//# sourceURL=webpack:///./node_modules/mbta-client/lib/constants.js?");

/***/ }),

/***/ "Du8b":
/*!*******************************************!*\
  !*** ./node_modules/mbta-client/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const MBTA = __webpack_require__(/*! ./lib/mbta */ \"kI9E\");\n\nmodule.exports = MBTA;\n\n\n//# sourceURL=webpack:///./node_modules/mbta-client/index.js?");

/***/ }),

/***/ "O/gq":
/*!***********************************************!*\
  !*** ./node_modules/mbta-client/lib/utils.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const { selectArrivalISOs, selectDepartureISOs } = __webpack_require__(/*! ./selectors */ \"ipIE\");\nconst isoRegex = /(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2}).000Z/;\n\nconst exists = value => value != null && value !== '';\n\nconst isEmptyArray = array =>\n  Array.isArray(array) && !array.filter(Boolean).length;\n\n/* eslint-disable camelcase */\nconst BASE_URL = 'https://api-v3.mbta.com';\n\n// CONVERSION FUNCTIONS\n\n/**\n * Converts array or string into comma separated string\n * @param {string | Array} value\n */\nconst commaSeparate = value =>\n  []\n    .concat(value)\n    .filter(Boolean)\n    .join(',')\n    .replace(/,\\s/g, ',');\n\n/**\n * Convert MS to given time units\n * @param {number} ms\n * @param {string} convertTo Time unit to convert MS to\n */\nconst convertMs = (ms, convertTo) => {\n  if (!exists(convertTo)) return ms;\n\n  const conversionMap = {\n    // Order here is important, because 'sec' input will\n    // match 'milliseconds' if it's before 'seconds'\n    'hours|hrs': 1000 * 60 * 60,\n    'minutes|mins': 1000 * 60,\n    'seconds|secs': 1000,\n    'ms|milliseconds': 1,\n  };\n\n  const converted = Object.keys(conversionMap).find(unit =>\n    new RegExp(convertTo, 'i').test(unit)\n  );\n\n  if (!exists(converted)) {\n    throw new Error(`Invalid 'convertTo' value: ${convertTo}`);\n  }\n\n  return ms / conversionMap[converted];\n};\n\n/**\n * Convert an array of ISO strings to <units> from now\n * @param {function} selector Select array of ISO times from response object\n */\nconst convertTimes = selector => options => {\n  const { response, max, convertTo, now = Date.now() } = options;\n\n  return selector(response)\n    .slice(0, max)\n    .map(isoString => {\n      // Note: arrival could be null if first stop on a route. Use departures\n      // if it's not null. Departure could be null if final stop on a route\n      // See https://www.mbta.com/developers/v3-api/best-practices for more info\n      if (convertTo == null || isoString == null) return isoString;\n\n      const msFromNow = new Date(isoString).valueOf() - now;\n      const unitsFromNow = Math.floor(convertMs(msFromNow, convertTo));\n\n      return unitsFromNow >= 0 ? unitsFromNow : 0;\n    });\n};\n\nconst arrivalsWithConversion = convertTimes(selectArrivalISOs);\nconst departuresWithConversion = convertTimes(selectDepartureISOs);\n\n// NORMALIZATION FUNCTIONS\n\n/**\n * Takes any kind of input, returns an ISO string.\n * Throws if input is malformed.\n * @param {number | string | Date} value\n */\nconst normalizeDate = value => new Date(value).toISOString();\n\n/**\n * Handles number or string input and returns numeric type based on:\n * https://developers.google.com/transit/gtfs/reference/routes-file\n * @param {string} type\n */\nconst normalizeType = type => {\n  const typeNames = [\n    'tram|light rail|streetcar|trolley',\n    'subway|metro|train',\n    'rail|commuter|commuter rail',\n    'bus|autobus',\n    'ferry|boat',\n    'cable car',\n    'gondola|suspended cable car',\n    'funicular',\n  ];\n\n  const typeAsNum = Number(type);\n\n  if (!exists(type) || typeAsNum >= typeNames.length) {\n    console.warn(`Invalid type: ${type}`);\n    return null;\n  }\n  // NaN !== NaN quick string check\n  // eslint-disable-next-line\n  if (typeAsNum === typeAsNum) {\n    return typeAsNum;\n  }\n  const normalized = typeNames.findIndex(name =>\n    new RegExp(type, 'i').test(name)\n  );\n  return normalized > -1 ? normalized : null;\n};\n\nconst addApiKey = (url, apiKey) => {\n  if (!exists(apiKey)) {\n    console.warn(\n      'API key is missing. Keys available at https://api-v3.mbta.com'\n    );\n    return `${url}`;\n  }\n  const delimiter = url.includes('?') ? '&' : '?';\n  return `${url}${delimiter}api_key=${apiKey}`;\n};\n\n/**\n * URL construction function\n * @param {string} endpoint\n * @param {object} queryParams Specific to each endpoint\n * @param {string} apiKey\n */\nfunction buildUrl(endpoint, queryParams, apiKey) {\n  const url = BASE_URL + endpoint;\n\n  if (!endpoint) {\n    throw new Error(\n      'Please provide an endpoint. See https://api-v3.mbta.com/docs/swagger/index.html'\n    );\n  }\n\n  if (!queryParams || !Object.keys(queryParams).length) {\n    return addApiKey(url, apiKey);\n  }\n\n  const {\n    limit,\n    offset,\n    latitude,\n    longitude,\n    descending,\n    min_time,\n    max_time,\n    radius,\n    route,\n    stop,\n    sort,\n    trip,\n  } = queryParams;\n\n  const matchRoute = test => test === endpoint;\n\n  if (\n    (matchRoute('/predictions') || matchRoute('/schedules')) &&\n    (!exists(stop) && !exists(trip) && !exists(route))\n  ) {\n    console.warn('Please include \"stop\", \"trip\", or \"route\"');\n  }\n\n  if (matchRoute('/shapes') && !exists(route)) {\n    console.warn('Shape requires a \"route\" param');\n  }\n\n  if (exists(offset) && !exists(limit)) {\n    console.warn('\"offset\" will have no effect without \"limit\"');\n  }\n\n  if (\n    (exists(latitude) && !exists(longitude)) ||\n    (!exists(latitude) && exists(longitude))\n  ) {\n    console.warn('Latitude and longitude must both be present');\n  }\n\n  if (exists(radius) && (!exists(latitude) || !exists(longitude))) {\n    console.warn('Radius requires latitude and longitude');\n  }\n\n  if (exists(descending) && !exists(sort)) {\n    console.warn('\"descending\" has no effect without \"sort\"');\n  }\n\n  [min_time, max_time].forEach(minMax => {\n    if (exists(minMax) && !/^\\d{2}:\\d{2}/.test(minMax)) {\n      console.warn('min_time and max_time format should be HH:MM');\n    }\n  });\n\n  // Convert queryParams into string values for URL\n  const queryString = Object.entries(queryParams)\n    .map(([key, value]) => {\n      let finalValue;\n      switch (key) {\n        case 'sort':\n          return queryParams.descending ? `sort=-${value}` : `sort=${value}`;\n        case 'limit':\n        case 'offset':\n          return `page[${key}]=${value}`;\n        case 'date':\n          finalValue = [].concat(value).map(normalizeDate);\n          break;\n        case 'route_type':\n        case 'type':\n          finalValue = [].concat(value).map(normalizeType);\n          break;\n        default:\n          finalValue = value;\n      }\n\n      if (!exists(finalValue) || isEmptyArray(finalValue)) {\n        return null;\n      }\n\n      // MBTA docs say to use filter[stop], filter[route], etc, but they\n      // also support stop, route, etc. without filter\n      return `${key}=${commaSeparate(finalValue)}`;\n    })\n    // Filter out falsy values, and 'descending' since it's only used for 'sort' logic\n    .filter(param => !!param && !/descending/.test(param))\n    .join('&');\n\n  return addApiKey(`${url}?${queryString}`, apiKey);\n}\n\nmodule.exports = {\n  exists,\n  buildUrl,\n  isoRegex,\n  convertMs,\n  convertTimes,\n  isEmptyArray,\n  normalizeType,\n  normalizeDate,\n  arrivalsWithConversion,\n  departuresWithConversion,\n};\n\n\n//# sourceURL=webpack:///./node_modules/mbta-client/lib/utils.js?");

/***/ }),

/***/ "UTCl":
/*!******************************************************!*\
  !*** ./node_modules/mbta-client/lib/fetchService.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const axios = __webpack_require__(/*! axios */ \"vDqi\");\n\nconst fetchService = async (url, service = axios) => {\n  try {\n    const res = await service.get(url);\n    if (!res || !res.data) {\n      throw new Error('No data from MBTA');\n    }\n    return res.data;\n  } catch (err) {\n    const { response } = err;\n    if (response && response.data && response.data.errors) {\n      const [error] = response.data.errors;\n      console.error(\n        `Error ${error.status ||\n          error.code} fetching MBTA data: ${error.detail || '(no details)'}`\n      );\n      throw error;\n    } else {\n      console.error('Error fetching MBTA data:', err.message);\n    }\n    throw err;\n  }\n};\n\nmodule.exports = fetchService;\n\n\n//# sourceURL=webpack:///./node_modules/mbta-client/lib/fetchService.js?");

/***/ }),

/***/ "ipIE":
/*!***************************************************!*\
  !*** ./node_modules/mbta-client/lib/selectors.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const { Attributes } = __webpack_require__(/*! ./constants */ \"0JQN\");\n\nconst selectAttribute = attr => response => {\n  if (!response || !response.data) {\n    console.warn('No response data...');\n    return [];\n  }\n\n  return response.data.map(vehicle => vehicle.attributes[attr]);\n};\n\nconst selectLinks = response => {\n  if (!response) {\n    throw new Error('No response, fetch data before accessing this value');\n  }\n  if (!response.links) {\n    throw new Error('response.links does not exist, \"limit\" must be in fetch options');\n  }\n  return response.links;\n};\n\nconst selectIncluded = (response, type) => {\n  if (!response) {\n    throw new Error('included() requires an MBTA response as an argument');\n  }\n  if (!response.included) {\n    console.warn('response.included does not exist, \"include\" must be in fetch options');\n    return [];\n  }\n  return response.included.filter(inc => {\n    if (Array.isArray(type)) {\n      return type.includes(inc.type);\n    }\n    return type === inc.type || type == null;\n  });\n};\n\nconst selectPage = (page, response) => selectLinks(response)[page];\n\nconst selectArrivalISOs = selectAttribute(Attributes.arrival_time);\nconst selectDepartureISOs = selectAttribute(Attributes.departure_time);\n\nmodule.exports = {\n  selectPage,\n  selectIncluded,\n  selectArrivalISOs,\n  selectDepartureISOs,\n};\n\n\n//# sourceURL=webpack:///./node_modules/mbta-client/lib/selectors.js?");

/***/ }),

/***/ "kI9E":
/*!**********************************************!*\
  !*** ./node_modules/mbta-client/lib/mbta.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* eslint-disable camelcase */\nconst {\n  buildUrl,\n  arrivalsWithConversion,\n  departuresWithConversion,\n} = __webpack_require__(/*! ./utils */ \"O/gq\");\nconst { selectPage, selectIncluded } = __webpack_require__(/*! ./selectors */ \"ipIE\");\nconst fetchService = __webpack_require__(/*! ./fetchService */ \"UTCl\");\nconst { Pagination } = __webpack_require__(/*! ./constants */ \"0JQN\");\n\n// TODO: filterByAttribute\n// TODO: filterByRelationship\n\n/**\n * Node.js client for the MBTA v3 API\n * https://api-v3.mbta.com\n */\nclass MBTA {\n  constructor(apiKey, fetch = fetchService) {\n    this.apiKey = apiKey;\n    this.fetch = fetch;\n  }\n\n  /**\n   * Fetch functions\n   */\n  async fetchPredictions(queryParams) {\n    return this.fetch(buildUrl('/predictions', queryParams, this.apiKey));\n  }\n\n  async fetchStops(queryParams) {\n    return this.fetch(buildUrl('/stops', queryParams, this.apiKey));\n  }\n\n  async fetchTrips(queryParams) {\n    return this.fetch(buildUrl('/trips', queryParams, this.apiKey));\n  }\n\n  async fetchRoutes(queryParams) {\n    return this.fetch(buildUrl('/routes', queryParams, this.apiKey));\n  }\n\n  async fetchVehicles(queryParams) {\n    return this.fetch(buildUrl('/vehicles', queryParams, this.apiKey));\n  }\n\n  async fetchShapes(queryParams) {\n    return this.fetch(buildUrl('/shapes', queryParams, this.apiKey));\n  }\n\n  async fetchServices(queryParams) {\n    return this.fetch(buildUrl('/services', queryParams, this.apiKey));\n  }\n\n  async fetchSchedules(queryParams) {\n    return this.fetch(buildUrl('/schedules', queryParams, this.apiKey));\n  }\n\n  async fetchFacilities(queryParams) {\n    return this.fetch(buildUrl('/facilities', queryParams, this.apiKey));\n  }\n\n  async fetchLiveFacilities(queryParams) {\n    return this.fetch(buildUrl('/live-facilities', queryParams, this.apiKey));\n  }\n\n  async fetchAlerts(queryParams) {\n    return this.fetch(buildUrl('/alerts', queryParams, this.apiKey));\n  }\n\n  /**\n   * Fetch helper functions\n   */\n  async fetchAllRoutes(filters) {\n    // Example: filter by { type: 3 } to get all bus routes\n    const routes = await this.fetchRoutes(filters);\n    return routes.data.map(route => {\n      const { short_name } = route.attributes;\n      // Only include short_name if it exists and is different from `id`\n      const maybeAbbr =\n        short_name && short_name !== route.id ? { short_name } : {};\n      return {\n        ...maybeAbbr,\n        id: route.id,\n        long_name: route.attributes.long_name,\n        direction_names: route.attributes.direction_names,\n      };\n    });\n  }\n\n  async fetchStopsByRoute(route) {\n    const stops = await this.fetchStops({ route });\n    return stops.data.map(stop => ({\n      name: stop.attributes.name,\n      id: stop.id,\n    }));\n  }\n\n  async fetchStopsByName(name, { exact } = {}) {\n    const allStops = await this.fetchStops();\n    const normalizedName = name.trim().toLowerCase();\n    return allStops.data.filter(stop => {\n      if (exact) {\n        return stop.attributes.name.toLowerCase() === normalizedName;\n      }\n      return stop.attributes.name.toLowerCase().match(normalizedName);\n    });\n  }\n\n  /**\n   * Select arrival/departure times from predictions with options to limit\n   * the number of arrivals returned, and convert them to time from now\n   */\n  selectArrivals(response, { convertTo, now } = {}) {\n    return arrivalsWithConversion({ response, convertTo, now });\n  }\n\n  selectDepartures(response, { convertTo, now } = {}) {\n    return departuresWithConversion({ response, convertTo, now });\n  }\n\n  /**\n   * Select included objects by type. An array of types will return\n   * objects matching any of the specified types. Omitting 'type'\n   * will return the unfiltered 'included' array.\n   */\n  selectIncluded(response, type) {\n    return selectIncluded(response, type);\n  }\n\n  /**\n   * Helper functions to fetch pages when working\n   * with a response that includes paginated links\n   */\n  async fetchFirstPage(response) {\n    return this.fetch(selectPage(Pagination.first, response));\n  }\n\n  async fetchNextPage(response) {\n    return this.fetch(selectPage(Pagination.next, response));\n  }\n\n  async fetchPrevPage(response) {\n    return this.fetch(selectPage(Pagination.prev, response));\n  }\n\n  async fetchLastPage(response) {\n    return this.fetch(selectPage(Pagination.last, response));\n  }\n}\n\nmodule.exports = MBTA;\n\n\n//# sourceURL=webpack:///./node_modules/mbta-client/lib/mbta.js?");

/***/ })

}]);